#[macro_use]
extern crate hex_literal;

mod asn;

use rsa::{BigUint, PaddingScheme, PublicKey, RSAPrivateKey, RSAPublicKey};

fn main() {
    let der_pvt = hex!("3082025C02010002818100950AD51731BCAF46E03D3FA0027C69E4B90658376325D286A3CA9C64F6A08C8F7D3841493E543944C73C3B70F540F7645792CBB2A49B9E97D52A34E6B66644310DCB237BE278FAC33BE3AAA0EEFFFA828E0AA0372CE5F4C056B48965AC6FF64319B4E399947154F1862CD51FBFF326CD86833BB22BEA5B3604806AAC4D3DD45B02030100010281807FA7F08E563E7B8E6460718F96B1836DB1809AAC8E1286386630133672FB5E8944429BC0A54F34621198287D7EC32F625593D93EE0B89DE504628B3F14F990EB77E1A0E5929FDF37DAABCD412B51E13D455D8220898A35D049FA5FED0DB060FFE4353E89A5C28983B4040FC18051741FA2CF3528581E7BEE84547B7A542045B1024100CF757467D639C9437758934672771D8E7D96B4A46FDF5CB8FF2B563F865C228E5FAC04993B3737497CB7677FD468929EFFF3279C20A4151DB0E53561DF8260B3024100B7EA4BE969BA5A5E2B9AF2E1EB7E64DBC592C8B9B825A660EC1126D1DC8DD8E05EE3F7C8BD652727AF86595D2BBC8AEFDF5966D0154DD5C5A6A09D048FE5C1B902410093DD5C7D921417DE6D57058985965ECBABB9D9C10637C687D8DF9396AD7647EF0043C3F74F5C789C7936E39F19CEFB0A36D5A15AC76D0BDBE0B44DCB179A7EBF024051D3562EE5315A1F67BB2AB0C53B98D806D145A90B7B04C93E7E6B0D17D9AC523725AA0A8FE93F4072E18D44DCBEA7FA0D1F139524C55A84F39BA6006F9D435102405829C678967B084806AD8CAD8CF15DEB579893D9ABD4BDB45E1BA867D024E198E63B2386FEBE28F65231D84F21D2B9A7D3B06CC8BAD22B01C5EA83FAFCDA1818");
    let der_pub = hex!("30818902818100C0822C2E70BE037A7FA1225974EDB053940CF7F8AF06F6AEEE37AE50803887B54AC5F5D5144368A13BD73CFE40C41E5742D344B2FCBF07DE4BDA781ABB8702FEF9BCD4941D59C7EBAAFF982B0A261ED6440CD96A5CD766AD4F0B60E2A328C8110EC6F19D243905AE10799CDF7A213BEBCDDE9206305FB8BA55EBAEE5DD09299D0203010001");
    println!("{:?}", get_private(&der_pvt));
    println!("{:?}", get_public(&der_pub));
}

fn get_private(data: &[u8]) -> Option<RSAPrivateKey> {
    if let Some(seq) = asn::split(&data) {
        if seq.len() == 9 {
            let n = BigUint::from_bytes_be(&seq[1]);
            let e = BigUint::from_bytes_be(&seq[2]);
            let d = BigUint::from_bytes_be(&seq[3]);
            let pq = vec![
                BigUint::from_bytes_be(seq[4]),
                BigUint::from_bytes_be(seq[5]),
            ];
            return Some(RSAPrivateKey::from_components(n, e, d, pq));
        }
    };
    return None;
}

fn get_public(data: &[u8]) -> Option<RSAPublicKey> {
    if let Some(seq) = asn::split(&data) {
        if seq.len() == 2 {
            let n = BigUint::from_bytes_be(&seq[0]);
            let e = BigUint::from_bytes_be(&seq[1]);
            if let Ok(key) = RSAPublicKey::new(n, e) {
                return Some(key);
            }
        }
    }
    return None;
}
